
## 一、结构体基础

### 1.1 结构体的定义

结构体是一种**自定义数据类型**，可以将不同类型的数据组合在一起。

```c
// 定义结构体类型
struct Book {
    int id;           // 书号
    char name[50];    // 书名
    float price;      // 价格
};

// 使用typedef简化
typedef struct {
    int id;
    char name[50];
    float price;
} Book;
```

### 1.2 结构体初始化规则

⚠️ **重要规则**：
- ❌ 结构体定义时**不能直接初始化**
- ✅ 只能声明成员，赋值在创建变量时进行

```c
// ❌ 错误示例
typedef struct {
    char name = '0';  // 错误！不能在定义时赋值
    int id = 0;       // 错误！
} Book;

// ✅ 正确示例
typedef struct {
    char name[50];    // 只声明
    int id;           // 只声明
    float price;      // 只声明
} Book;

// 初始化在声明变量时进行
Book book1 = {1, "C语言", 45.5};
```

---

## 二、结构体数组

### 2.1 声明和使用

```c
Book books[100];  // 声明100个Book的数组

// 访问数组元素
books[0].id = 1;
strcpy(books[0].name, "数据结构");
books[0].price = 38.0;

// 循环遍历
for(int i = 0; i < n; i++) {
    printf("%d %s %.2f\n", books[i].id, books[i].name, books[i].price);
}
```

### 2.2 嵌套结构体

```c
// 成绩结构体
typedef struct {
    float grade_1;
    float grade_2;
    float grade_3;
} Grade;

// 学生结构体（嵌套）
typedef struct {
    int id;
    char name[10];
    Grade i;  // 嵌套结构体
} student;

// 访问嵌套成员
student s;
s.i.grade_1 = 90.0;
```

---

## 三、结构体在函数中的传递

### 3.1 值传递（不推荐）

```c
void printBook(Book b) {
    printf("%d %s %.2f\n", b.id, b.name, b.price);
}
// 缺点：复制整个结构体，效率低
```

### 3.2 地址传递（⭐推荐）

```c
void printBook(Book *p) {
    printf("%d %s %.2f\n", p->id, p->name, p->price);
}
// 优点：只传递地址，效率高
```

### 3.3 传递结构体数组

```c
int findBook(Book arr[], int n, char *name) {
    for(int i = 0; i < n; i++) {
        if(strcmp(arr[i].name, name) == 0) {
            return i;  // 找到返回下标
        }
    }
    return -1;  // 未找到
}
```

---

## 四、指针访问结构体成员

### 4.1 三种访问方式

```c
Book books[10];
Book *p = books;

// 方式1: 数组下标 + 点访问（⭐最清晰）
books[i].name
books[i].id

// 方式2: 指针运算 + 箭头访问
(p+i)->name
(p+i)->id

// 方式3: 解引用 + 点访问（不推荐，括号多）
(*(p+i)).name
(*(p+i)).id
```

### 4.2 箭头运算符 `->`

```c
Book *p = &book;

// 以下两种写法等价：
p->id       // 箭头访问（推荐）
(*p).id     // 解引用后点访问
```

### 4.3 `*p` 的含义

```c
Book *p;     // p 是指针，存储Book类型变量的地址
*p           // *p 是解引用，访问指针指向的Book结构体变量

// 示例
Book book[10];
Book *p = book;

p         // 地址 (如 0x1000)
*p        // 第一个Book结构体 (即 book[0])
(*p).id   // book[0].id
p->id     // 等价于 (*p).id（推荐写法）
```

---

## 五、字符串处理

### 5.1 字符串 vs 字符

```c
char ch = 'A';              // 单个字符，用单引号
char str[] = "Hello";       // 字符串，用双引号

// ❌ 错误
char name;                  // 只能存1个字符
char name = "语文";         // 错误！单个字符不能存字符串

// ✅ 正确
char name[50];              // 字符数组，可存字符串
char name[50] = "语文";     // 正确
```

### 5.2 为什么字符串要用字符数组？

**字符串的本质 = 字符数组 + '\0'结束符**

```c
char name[50] = "Hello";
// 实际存储: {'H','e','l','l','o','\0', ...}
//            0   1   2   3   4   5

// 内存示意
name[50]: [H][e][l][l][o][\0][  ][  ]...
           0  1  2  3  4   5   6   7
```

### 5.3 strcmp - 字符串比较

```c
#include <string.h>

// ❌ 错误：不能用 == 比较字符串
if(str1 == str2)  // 这是比较地址，不是内容！

// ✅ 正确：使用 strcmp
if(strcmp(str1, str2) == 0)  // 返回0表示相等

// 返回值规则
strcmp(s1, s2) < 0   // s1 < s2
strcmp(s1, s2) == 0  // s1 == s2 (相等) ✅
strcmp(s1, s2) > 0   // s1 > s2
```

### 5.4 strcpy - 字符串复制

```c
#include <string.h>

char dest[50];
char src[] = "Hello";

// ❌ 错误：不能用 = 赋值字符串
dest = src;  // 错误！数组名不能被赋值

// ✅ 正确：使用 strcpy
strcpy(dest, src);  // 将 src 复制到 dest
```

---

## 六、数组名与指针

### 6.1 数组名的本质

```c
int arr[10];

arr        // 数组名，类型是 int*（指向首元素的指针）
arr[0]     // 第一个元素的值，类型是 int
&arr       // 整个数组的地址，类型是 int (*)[10]
```

### 6.2 `&book[i].name` 的问题

```c
char name[50];

name        // 数组名，值是 char* 类型的地址
&name       // 整个数组的地址，类型是 char (*)[50]

// 虽然地址值相同，但类型不同！
printf("%p\n", name);    // 输出: 0x1000 (char*)
printf("%p\n", &name);   // 输出: 0x1000 (char (*)[50])

// scanf 使用
scanf("%s", book[i].name);    // ✅ 推荐：char* 类型
scanf("%s", &book[i].name);   // ⚠️ 能用但不规范：char (*)[50] 类型
```

---

## 七、实战案例解析

### 7.1 题目3：书籍查找系统

```c
typedef struct {
    int id;
    char name[50];
    float price;
} Book;

int findbook(Book *p, int n, char *f) {
    for(int i = 0; i < n; i++) {
        if(strcmp((p+i)->name, f) == 0) {  // 字符串比较用strcmp
            return i;  // 找到返回下标
        }
    }
    return -1;  // 未找到返回-1
}

int main() {
    Book book[100];
    int j = 0;
    char find[100] = {0};
    
    printf("请输入要储存多少本书：");
    scanf("%d", &j);
    
    for(int i = 0; i < j; i++) {
        scanf("%d %s %f", &book[i].id, book[i].name, &book[i].price);
        // 注意：name不加&，因为数组名本身就是地址
    }
    
    printf("请输入要查询的书籍名：");
    scanf("%s", find);
    
    int number = findbook(book, j, find);
    
    if(number != -1) {
        printf("%d %s %.2f\n", book[number].id, 
               book[number].name, book[number].price);
    } else {
        printf("no find\n");
    }
    
    return 0;
}
```

### 7.2 题目4：复数相加

```c
typedef struct {
    float real;  // 实部
    float fake;  // 虚部
} complex;

complex Complex_number_add(complex n1, complex n2) {
    complex num;
    num.real = n1.real + n2.real;
    num.fake = n1.fake + n2.fake;
    return num;
}

int main() {
    complex number1, number2;
    
    printf("please input number1(实部 虚部): ");
    scanf("%f %f", &number1.real, &number1.fake);
    
    printf("please input number2(实部 虚部): ");
    scanf("%f %f", &number2.real, &number2.fake);
    
    complex n = Complex_number_add(number1, number2);
    
    // ✅ 正确：float用%f，不用%d
    printf("output: %.2f+%.2fi\n", n.real, n.fake);
    
    return 0;
}
```

**⚠️ 常见错误**：
```c
printf("output %d+%di", n.real, n.fake);  // ❌ 错误！%d用于int，应该用%f
```

### 7.3 附加题：学生成绩管理系统

```c
typedef struct {
    float grade_1;
    float grade_2;
    float grade_3;
} Grade;

typedef struct {
    int id;
    char name[10];
    Grade i;
} student;

// 输入函数
void Input(student *p, int n) {
    for(int i = 0; i < n; i++) {
        printf("请输入第%d名学生的数据(id 姓名 成绩1 成绩2 成绩3)\n", i+1);
        scanf("%d %s %f %f %f", &(p+i)->id, (p+i)->name, 
              &(p+i)->i.grade_1, &(p+i)->i.grade_2, &(p+i)->i.grade_3);
    }
}

// 计算平均分函数
void Calculate(student *q, int m, float *k) {
    for(int i = 0; i < m; i++) {
        // ✅ 三门课都要加上
        k[i] = ((q+i)->i.grade_1 + (q+i)->i.grade_2 + (q+i)->i.grade_3) / 3.0;
    }
}

// 查找平均分最高的学生
int max(student *u, float *avg, int v) {
    int maxIndex = 0;
    float maxAvg = avg[0];
    
    for(int i = 1; i < v; i++) {
        if(avg[i] > maxAvg) {
            maxAvg = avg[i];
            maxIndex = i;
        }
    }
    return maxIndex;
}

int main() {
    float average[10] = {0};  // ✅ 必须是float类型
    student S[10];
    int n = 0;
    
    printf("请输入需要录入几名学生信息:");
    scanf("%d", &n);
    
    Input(S, n);
    Calculate(S, n, average);
    int number = max(S, average, n);  // ✅ 传入average
    
    // 输出所有学生信息
    for(int i = 0; i < n; i++) {
        printf("序号%d 学生%s的平均分为:%.1f,grade1:%.1f,grade2:%.1f,grade3:%.1f\n",
               S[i].id, S[i].name, average[i], 
               S[i].i.grade_1, S[i].i.grade_2, S[i].i.grade_3);
    }
    
    // 输出平均分最高的学生
    printf("\n其中平均分最高的学生的数据如下:\n");
    printf("序号%d 学生%s的平均分为:%.1f,grade1:%.1f,grade2:%.1f,grade3:%.1f\n",
           S[number].id, S[number].name, average[number],
           S[number].i.grade_1, S[number].i.grade_2, S[number].i.grade_3);
    
    return 0;
}
```

**⚠️ 常见错误**：

1. **平均分数组类型错误**
```c
int average[10];  // ❌ 错误！平均分是小数，应该用float
float average[10];  // ✅ 正确
```

2. **Calculate函数参数类型错误**
```c
void Calculate(student*q, int m, int*k)  // ❌ 错误
void Calculate(student*q, int m, float*k)  // ✅ 正确
```

3. **Max函数逻辑错误**
```c
// ❌ 错误：查找单科最高分
int Max(student*u, int v) {
    if((u+i)->i.grade_1 > max) { ... }
}

// ✅ 正确：查找平均分最高
int max(student*u, float*avg, int v) {
    if(avg[i] > maxAvg) { ... }
}
```

---

## 八、格式符对照表

| 数据类型 | scanf | printf | 注意事项 |
|---------|-------|--------|---------|
| `int` | `%d` | `%d` | 整数 |
| `float` | `%f` | `%f` 或 `%.2f` | **scanf用%f，不用%.2f** |
| `double` | `%lf` | `%f` | scanf用%lf，printf用%f |
| `char` | `%c` | `%c` | 单个字符 |
| `char[]` | `%s` | `%s` | 字符串 |

---

## 九、文件操作基础

### 9.1 文件操作流程

```
1. 打开文件 (fopen)    → 翻开笔记本
2. 读/写文件           → 读/写内容
3. 关闭文件 (fclose)   → 合上笔记本
```

### 9.2 文件打开模式

| 模式 | 说明 | 文件不存在 | 文件已存在 |
|------|------|-----------|-----------|
| `"r"` | 只读 | 失败 | 从头读 |
| `"w"` | 只写 | 创建新文件 | **清空原内容** |
| `"a"` | 追加 | 创建新文件 | 在末尾追加 |
| `"r+"` | 读写 | 失败 | 从头开始 |
| `"w+"` | 读写 | 创建新文件 | **清空原内容** |
| `"a+"` | 读写 | 创建新文件 | 在末尾追加 |

### 9.3 基本文件操作

```c
#include <stdio.h>

// 写入文件
FILE *fp = fopen("data.txt", "w");
if(fp == NULL) {
    printf("文件打开失败！\n");
    return 1;
}

fprintf(fp, "学号: %d\n", 1001);
fprintf(fp, "姓名: %s\n", "张三");
fprintf(fp, "成绩: %.1f\n", 85.5);

fclose(fp);

// 读取文件
fp = fopen("data.txt", "r");

int id;
char name[50];
float score;

fscanf(fp, "学号: %d\n", &id);
fscanf(fp, "姓名: %s\n", name);
fscanf(fp, "成绩: %f\n", &score);

printf("读取到: %d %s %.1f\n", id, name, score);

fclose(fp);
```

### 9.4 保存学生数据到文件

```c
void SaveToFile(student *S, float *average, int n) {
    FILE *fp = fopen("student_data.txt", "w");
    
    if(fp == NULL) {
        printf("文件打开失败！\n");
        return;
    }
    
    fprintf(fp, "学号\t姓名\t成绩1\t成绩2\t成绩3\t平均分\n");
    
    for(int i = 0; i < n; i++) {
        fprintf(fp, "%d\t%s\t%.1f\t%.1f\t%.1f\t%.1f\n",
                S[i].id, S[i].name,
                S[i].i.grade_1, S[i].i.grade_2, S[i].i.grade_3,
                average[i]);
    }
    
    fclose(fp);
    printf("✅ 数据已保存到文件\n");
}
```

---

## 十、常用函数总结

### 10.1 字符串函数（需要 `#include <string.h>`）

| 函数 | 功能 | 示例 |
|------|------|------|
| `strcmp(s1, s2)` | 比较字符串 | `if(strcmp(s1,s2)==0)` |
| `strcpy(dest, src)` | 复制字符串 | `strcpy(dest, src)` |
| `strlen(str)` | 获取字符串长度 | `int len = strlen(str)` |
| `strcat(dest, src)` | 字符串拼接 | `strcat(dest, src)` |

### 10.2 文件操作函数

| 函数 | 功能 | 类比 |
|------|------|------|
| `fopen()` | 打开文件 | 翻开笔记本 |
| `fclose()` | 关闭文件 | 合上笔记本 |
| `fprintf()` | 格式化写入 | 像printf写到文件 |
| `fscanf()` | 格式化读取 | 像scanf从文件读 |
| `fputc()` | 写入字符 | 写一个字 |
| `fgetc()` | 读取字符 | 读一个字 |
| `fputs()` | 写入字符串 | 写一行 |
| `fgets()` | 读取字符串 | 读一行 |

---

## 十一、常见错误总结

### 11.1 结构体相关

| 错误 | 原因 | 正确做法 |
|------|------|---------|
| 结构体定义时赋初值 | 不允许在定义时初始化 | 只声明，创建变量时初始化 |
| `char name` 存书名 | 单个字符存不下字符串 | 用 `char name[50]` |
| 缺少 `price` 字段 | 题目要求输出价格 | 添加 `float price` |

### 11.2 字符串相关

| 错误 | 原因 | 正确做法 |
|------|------|---------|
| `if(str1 == str2)` | 比较的是地址 | 用 `strcmp(str1,str2)==0` |
| `str1 = str2` | 数组名不能赋值 | 用 `strcpy(str1, str2)` |
| `scanf("%.1f", &f)` | scanf不能用精度 | 用 `scanf("%f", &f)` |

### 11.3 平均分计算相关

| 错误 | 原因 | 正确做法 |
|------|------|---------|
| `int average[]` | 平均分是小数 | 改为 `float average[]` |
| `int*k` 参数 | 类型不匹配 | 改为 `float*k` |
| 三次加 `grade_1` | 复制粘贴错误 | 改为 `grade_1+2+3` |
| 比较单科成绩 | 题目要求平均分最高 | 改为比较 `avg[i]` |

### 11.4 格式符相关

| 错误 | 原因 | 正确做法 |
|------|------|---------|
| `printf("%d", float)` | %d用于int | 改为 `%f` |
| `scanf("%.2f", &f)` | scanf不支持精度 | 改为 `%f` |

---

## 十二、学习心得

### 12.1 关键知识点

1. **结构体是自定义类型**，可以组合不同类型的数据
2. **数组名就是地址**，所以 `char name[50]` 不需要 `&`
3. **字符串比较用 `strcmp`**，不能用 `==`
4. **指针访问结构体用 `->`**，变量访问用 `.`
5. **函数传递结构体数组时传地址**，效率更高
6. **文件操作三部曲**：打开→读写→关闭

### 12.2 调试技巧

1. **编译错误 vs 运行错误**
   - 编译错误：语法问题，编译时报错
   - 运行错误：逻辑问题，运行时才发现

2. **类型匹配很重要**
   - `int` 配 `%d`
   - `float` 配 `%f`
   - `char*` 配 `%s`

3. **指针操作要小心**
   - 确保指针不为 NULL
   - 注意数组越界
   - 字符串末尾要有 `\0`

---

## 十三、今日完成题目

✅ **第3题**：书籍查找系统（findbook函数）  
✅ **第4题**：复数相加  
✅ **附加题**：学生成绩管理系统（Input、Calculate、Max函数）

**代码完成度**：⭐⭐⭐⭐⭐

---

## 十四、下次学习计划

1. 深入学习文件操作（二进制文件读写）
2. 链表数据结构
3. 动态内存分配（malloc、free）
4. 指针数组和数组指针
5. 函数指针

---

**总结**：今天重点掌握了结构体的定义、使用和在函数中的传递，以及字符串处理和基本的文件操作。通过三道实战题目，巩固了对结构体数组、指针操作和函数封装的理解。💪