# C语言指针与字符串操作知识总结

## 一、字符串长度统计

### 1.1 数组作为函数参数的退化机制

```c
// 函数声明中，数组参数会退化为指针
int calculate(char arr[], int n);  // arr 实际上是 char* 类型
int calculate(char *p, int n);     // 完全等价
```

**关键点：**
- 数组名作为函数参数时，会退化为指向首元素的指针
- `sizeof(arr)` 在函数内部计算的是指针大小，不是数组大小
- 因此需要额外传递数组长度参数

### 1.2 两种实现方式对比

#### 方式1：使用数组名形参
```c
int calculate(char arr[], int n) {
    int i, j = 0;
    for(i = 0; i < n; i++) {
        if(arr[i] == '\0') {
            j = i;
            break;
        }
    }
    return j;
}
```

#### 方式2：使用指针形参
```c
int calculate(char *p, int n) {
    int len = 0;
    while(*p != '\0') {
        len++;
        p++;  // 指针移动
    }
    return len;
}
```

**对比总结：**
| 特性 | 数组名形参 | 指针形参 |
|------|-----------|---------|
| 本质 | 退化为指针 | 指针变量 |
| 访问方式 | `arr[i]` | `*p` 或 `*(p+i)` |
| 指针移动 | 不移动，用索引 | 可以移动 `p++` |
| 可读性 | 更直观 | 更灵活 |

---

## 二、二维数组操作与指针

### 2.1 二维数组的指针表示

```c
int arr[5][5];
int (*p)[5] = arr;  // p 是指向包含5个int的数组的指针

// 访问方式对比：
arr[i][j]        ↔  *(*(p+i)+j)  ↔  p[i][j]
&arr[i][j]       ↔  (*(p+i)+j)   ↔  &p[i][j]
arr[i]           ↔  *(p+i)       ↔  p[i]
```

**类型分析：**
- `p` 类型：`int(*)[5]` (指向数组的指针)
- `p+i` 类型：`int(*)[5]` (指向第i行)
- `*(p+i)` 类型：`int*` (第i行的首元素指针)
- `*(p+i)+j` 类型：`int*` (指向第i行第j个元素)
- `*(*(p+i)+j)` 类型：`int` (具体的值)

### 2.2 矩阵元素交换问题

#### 关键：中间变量的作用

```c
// ❌ 错误：没有中间变量
a = b;
b = a;  // 此时a已经等于b了，原来的a丢失

// ✅ 正确：使用中间变量
temp = a;
a = b;
b = temp;
```

#### 边界情况处理

```c
void sort(int(*p)[5], int n, int r) {
    int max = *(*(p+0)+0);
    int min = *(*(p+0)+0);
    int a=0, b=0, c=0, d=0;  // 记录最大/最小值位置
    
    // 查找最大最小值
    for(i=0; i<n; i++) {
        for(j=0; j<r; j++) {
            if(*(*(p+i)+j) > max) {
                max = *(*(p+i)+j);
                a = i; b = j;
            }
            if(*(*(p+i)+j) < min) {
                min = *(*(p+i)+j);
                c = i; d = j;
            }
        }
    }
    
    // 第一步：最大值与中心交换
    temp = *(*(p+2)+2);
    *(*(p+2)+2) = *(*(p+a)+b);
    *(*(p+a)+b) = temp;
    
    // ⚠️ 关键：边界检查
    // 如果最小值原本在中心，交换后位置改变了
    if(c==2 && d==2) {
        c = a;
        d = b;
    }
    
    // 第二步：最小值与左上角交换
    temp = *(*p);
    *(*p) = *(*(p+c)+d);
    *(*(p+c)+d) = temp;
}
```

**为什么需要边界检查？**

如果最小值原本在中心 `(2,2)`，第一步交换后：
- 最小值被移到了 `(a,b)` 位置
- 但 `c,d` 还记录着 `(2,2)`
- 不更新会导致第二步交换错误

---

## 三、指向指针的指针（二级指针）

### 3.1 概念理解

```c
char ch = 'A';
char *p = &ch;      // p 是一级指针，指向字符
char **pp = &p;     // pp 是二级指针，指向指针

// 访问关系：
ch          // 直接访问：'A'
*p          // 通过一级指针：'A'
**pp        // 通过二级指针：'A'

// 地址关系：
&ch         // ch 的地址
p           // 存储 ch 的地址
*pp         // 解引用 pp 得到 p
&p          // p 的地址
pp          // 存储 p 的地址
```

### 3.2 字符指针数组

```c
char *str[5] = {"apple", "banana", "cherry", "date", "elderberry"};

// 内存布局：
// str[0] = 0x1000 → "apple"    (字符指针)
// str[1] = 0x2000 → "banana"   (字符指针)
// str[2] = 0x3000 → "cherry"   (字符指针)
// str[3] = 0x4000 → "date"     (字符指针)
// str[4] = 0x5000 → "elderberry" (字符指针)
```

**类型分析：**
- `str[i]` 类型：`char*` (字符指针)
- `str` 类型：`char*[5]` (字符指针数组)
- `str` 退化：`char**` (指向字符指针的指针)

### 3.3 数组名的退化规则

```c
char *str[5] = {"apple", "banana", ...};

// 三种写法：
char **p1 = str;        // ✅ str 自动退化为 char**
char **p2 = &str[0];    // ✅ 显式取第一个元素地址
char *(*p3)[5] = &str;  // ⚠️ 指向整个数组的指针，类型不同！

// 为什么不需要 & ？
// 因为数组名在表达式中自动退化为指向首元素的指针
str       ↔  &str[0]    // 值相同，类型相同
&str      // 类型是 char*(*)[5]，指向整个数组
```

**对比普通数组：**
```c
int arr[5] = {1, 2, 3, 4, 5};

int *p = arr;       // ✅ arr 退化为 int*
int *p = &arr[0];   // ✅ 等价
int (*pa)[5] = &arr; // ⚠️ 指向整个数组
```

### 3.4 二级指针的访问方式

```c
char *str[5] = {"apple", "banana", "cherry", "date", "elderberry"};
char **p = str;

// 多种等价访问方式：
p[0]         ↔  *(p+0)    ↔  *p          // "apple" 字符串
p[1]         ↔  *(p+1)                   // "banana" 字符串
p[i][j]      ↔  *(*(p+i)+j)  ↔  *(p[i]+j) // 第i个字符串的第j个字符

// 示例：
printf("%s", p[0]);        // 输出 "apple"
printf("%s", *(p+1));      // 输出 "banana"
printf("%c", p[2][0]);     // 输出 'c'
printf("%c", **(p+2));     // 输出 'c'
```

---

## 四、字符串连接函数实现

### 4.1 指针的值传递机制

**核心概念：**
- 指针作为参数是**值传递**
- 传递的是指针的副本（地址值的副本）
- 修改指针本身不影响原指针
- 通过指针修改内存内容会影响原内存

```c
void func(char *dst) {
    dst++;  // ❌ 只改变副本，不影响main中的指针
    *dst = 'X';  // ✅ 修改内存内容，main中能看到
}

int main() {
    char buffer[] = "hello";
    char *ptr = buffer;  // ptr = 0x1000
    
    func(ptr);
    
    // ptr 还是 0x1000（指针值没变）
    // 但 buffer 内容可能变了（内存被修改）
}
```

**内存布局图解：**
```
main 函数栈：
  buffer: ['h']['e']['l']['l']['o']['\0']  ← 0x1000
  ptr: [0x1000] ← 指针变量

调用 func(ptr)：
  
func 函数栈：
  dst: [0x1000] ← 复制了ptr的值（副本）

执行 dst++：
  dst: [0x1001] ← dst副本改变

执行 *dst = 'X'：
  buffer: ['h']['X']['l']['l']['o']['\0']  ← 内存被修改

返回main：
  ptr: [0x1000] ← ptr没变
  buffer: ['h']['X']['l']['l']['o']['\0']  ← 内容变了
```

### 4.2 指针移动的方式

#### 方式1：指针本身移动
```c
int cat_string(char *dst, char *src) {
    int count = 0;
    
    // 移动dst到末尾
    while(*dst != '\0') {
        dst++;  // 指针移动
    }
    
    // 从末尾开始复制
    while(*src != '\0') {
        *dst = *src;
        dst++;
        src++;
        count++;
    }
    *dst = '\0';
    
    return count;
}
```

#### 方式2：指针不动，用索引
```c
int cat_string(char *dst, char *src) {
    int i = 0;
    int count = 0;
    
    // 找到末尾
    while(*(dst+i) != '\0') {
        i++;
    }
    
    // 从末尾复制
    while(*(src+count) != '\0') {
        *(dst+i) = *(src+count);
        i++;
        count++;
    }
    *(dst+i) = '\0';
    
    return count;
}
```

**对比：**
| 方式 | 指针是否移动 | 优点 | 缺点 |
|------|-------------|------|------|
| `p++` | ✅ 移动 | 代码简洁 | 原指针位置丢失 |
| `*(p+i), i++` | ❌ 不动 | 保留原指针 | 需要额外变量 |

### 4.3 自增运算符：前置vs后置

```c
// 后置 p++：先使用，后自增
char c = *(p++);
// 等价于：
// char c = *p;
// p++;

// 前置 ++p：先自增，后使用
char c = *++p;
// 等价于：
// p++;
// char c = *p;
```

**在循环中的区别：**
```c
// 使用后置（常见错误）
while(1) {
    if(*(dst++) == '\0') {  // 先判断，后移动
        break;              // break时dst已经多移动了一步
    }
}
dst--;  // ⚠️ 需要回退

// 使用先判断后移动（推荐）
while(*dst != '\0') {
    dst++;
}
// dst正好指向'\0'位置
```

### 4.4 完整实现与要点

```c
int cat_string(char *dst, char *src) {
    int i = 0;
    
    // 1. 找到dst的'\0'位置
    while(1) {
        if(*(dst++) == '\0') {
            dst--;  // 回退到'\0'位置
            break;
        }
    }
    
    // 2. 从'\0'位置开始复制src
    for(i = 0; ; i++) {
        *(dst+i) = *(src+i);
        if(*(src+i) == '\0') {
            break;
        }
    }
    
    // 3. 返回复制的字符数
    return i;
}

int main() {
    char dst[200] = {0};  // ⚠️ 确保足够大
    char src[100] = {0};
    
    scanf("%s %s", dst, src);
    
    int len = cat_string(dst, src);
    
    printf("%s\n", dst);  // ✅ 在main中打印
    printf("%d\n", len);
    
    return 0;
}
```

**关键要点：**
1. **空间分配**：dst数组要足够大，至少 `strlen(dst) + strlen(src) + 1`
2. **输出位置**：在main函数中打印dst，因为函数内dst已经移动
3. **指针回退**：使用`*(dst++)`时需要`dst--`回退
4. **结束符**：确保添加`'\0'`结束符

---

## 五、易错点总结

### 5.1 指针与数组

| 易错点 | 错误理解 | 正确理解 |
|--------|---------|---------|
| 数组名 | 数组名是常量 | 数组名在表达式中退化为指针 |
| `&arr` | 和arr相同 | 类型不同，是指向整个数组的指针 |
| 指针赋值 | 数组可以赋值 | 数组名不能赋值，指针可以 |

### 5.2 指针传参

| 易错点 | 错误理解 | 正确理解 |
|--------|---------|---------|
| 值传递 | 指针传递是引用传递 | 指针是值传递，传的是地址值的副本 |
| 指针修改 | 函数内改指针会影响外部 | 改指针本身不影响，改内存内容才影响 |
| 返回指针 | 可以返回局部变量指针 | 不能返回局部变量的地址 |

### 5.3 字符串操作

| 易错点 | 错误代码 | 正确代码 |
|--------|---------|---------|
| 只读字符串 | `char *s="hi"; s[0]='H';` | `char s[]="hi"; s[0]='H';` |
| 空间不足 | `char s[5]; scanf("%s",s);` | `char s[100]; scanf("%99s",s);` |
| 忘记`\0` | `s[i]='a'; return i;` | `s[i]='a'; s[i+1]='\0';` |

---

## 六、调试技巧

### 6.1 打印指针信息
```c
printf("指针地址: %p\n", (void*)p);
printf("指针指向的内容: %c\n", *p);
printf("指针的值（数值形式）: %lu\n", (unsigned long)p);
```

### 6.2 验证内存修改
```c
void test(char *p) {
    printf("修改前: %s\n", p);
    *p = 'X';
    printf("修改后: %s\n", p);
}
```

### 6.3 检查边界条件
```c
// 测试特殊情况
- 空字符串 ""
- 单字符 "a"
- 最大/最小值在边界
- 重复元素
```

---

## 七、实践建议

1. **理解内存模型**：画图理解指针和内存的关系
2. **类型意识**：时刻注意指针的类型（几级指针）
3. **边界检查**：考虑特殊情况，添加必要的边界检查
4. **调试输出**：适当添加printf调试信息
5. **代码规范**：使用有意义的变量名，添加注释
6. **测试充分**：编写多个测试用例，覆盖边界情况